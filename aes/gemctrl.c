/*
 *************************************************************************
 *			Revision Control System
 * =======================================================================
 *  $Author: mui $	$Date: 89/04/26 18:21:33 $
 * =======================================================================
 *
 * Revision 2.3  89/04/26  18:21:33  mui
 * TT
 * 
 * Revision 2.2  89/04/06  17:58:24  kbad
 * changed hctl_window to use delay() system tick timer rather than evnt_ calls.
 * 
 * Revision 2.1  89/02/22  05:25:15  kbad
 * *** TOS 1.4  FINAL RELEASE VERSION ***
 * 
 * Revision 1.3  89/02/16  10:47:41  mui
 * Fix dclicks: take out gl_bpend stuf in ctrlmgr
 * 
 * Revision 1.2  89/02/14  08:51:45  kbad
 * fix at hctl_window to prevent double events being generated by single
 * clicks in window controls. 
 * 
 * Revision 1.1  88/06/02  12:31:14  lozben
 * Initial revision
 * 
 * Revision 1.1  87/11/20  14:14:07  lozben
 * Initial revision
 * 
 * =======================================================================
 *
 *************************************************************************
 */
/*	GEMCTRL.C	5/14/84 - 02/23/85	Lee Jay Lorenzen	*/
/*	pstart bugs,1.1	2/12/85 - 04/05/85	LKW			*/
/*	Reg Opt		03/09/85		Derek Mui		*/
/*	Fix at hctl_window 05/11/85 - 10/21/85	Derek Mui		*/
/*	Fix the button semaphore at ctlmgr	2/27/86	 Derek Mui	*/
/*	Ctlmouse to control the mouse 		03/05/86 Derek Mui	*/
/*	Change at ctlmouse to save mouse form by using line a function,	*/
/*	take out tmpmaddr	1/7/87		Derek Mui		*/
/*	Smooth scrolling	2/4/87		Derek Mui		*/
/*	Change at ctlmgr for smooth scrolling	3/11/87	Derek Mui	*/
/*	Fix at ctlmouse of gsx_ncode		12/11/87	D.Mui	*/
/*	Take out gl_fakemsg at hctl_button	2/17/88		D.Mui	*/
/*	Take out gl_fakemsg at hctl_button	6/25/90		D.Mui	*/
/*	Change the way it sends the arrow message 4/3/91	D.Mui	*/
/*	Change mn_do to mn_hdo			7/8/92		D.Mui	*/
/*	New codes to handle new window library	8/1/92		D.Mui	*/

/*
 *	-------------------------------------------------------------
 *	GEM Application Environment Services		  Version 1.1
 *	Serial No.  XXXX-0000-654321		  All Rights Reserved
 *	Copyright (C) 1985			Digital Research Inc.
 *	-------------------------------------------------------------
 */

#include "aes.h"
#include "gemlib.h"
#include "taddr.h"
#include "gsxdefs.h"


#if BINEXACT
extern int16_t gl_mnpid;
#endif

#define THEDESK 3

#define MBDOWN 0x0001
#define BELL 0x07						/* bell         */

LPTREE ml_mnhold;
GRECT ml_ctrl;
PD *ml_pmown;
PD *ml_pkown;
STATIC int16_t tmpmoff;
STATIC int16_t tmpmon;
MOBLK gl_ctwait;
int16_t appl_msg[8];
#if AES3D
int16_t deskwind;							/* added 7/25/91 window handle of DESKTOP */ /* WTF, what for? */
#endif
#if 0
int16_t rets[6];							/* added 2/4/87 ... and now unused */
#endif
int16_t ml_ocnt;

/* used to convert from window object # to window message code */
STATIC int16_t const gl_wa[] = {
	WA_UPLINE,
	WA_DNLINE,
	WA_UPPAGE,
	WA_DNPAGE,
	0x0,
	WA_LFLINE,
	WA_RTLINE,
	WA_LFPAGE,
	WA_RTPAGE
};


/*
 *	Send message and wait for the mouse button to come up
 */
/* 306de: 00e1b1b4 */
VOID ct_msgup(P(int16_t) message, P(int16_t) owner, P(int16_t) wh, P(int16_t) m1, P(int16_t) m2, P(int16_t) m3, P(int16_t) m4)
PP(int16_t message;)
PP(int16_t owner;)
PP(int16_t wh;)
PP(int16_t m1;)
PP(int16_t m2;)
PP(int16_t m3;)
PP(int16_t m4;)
{
	if (message)
		ap_sendmsg(appl_msg, message, owner, wh, m1, m2, m3, m4);
	/* wait for button to come up */
	while ((button & 0x0001) != 0x0)
		dsptch();
}


/* 306de: 00e1b1f4 */
VOID hctl_window(P(int16_t) w_handle, P(int16_t) mx, P(int16_t) my)
PP(register int16_t w_handle;)
PP(int16_t mx;)
PP(int16_t my;)
{
#if NEWWIN
	GRECT t, f;
	int16_t x, y, w, h;
	int16_t wm, hm;
	register int16_t kind, gadget;
	int16_t xelev, yelev;
	register int16_t message, cpt;
	LPTREE tree;
	register WINDOW *pwin;
	int16_t lrets[6];
	int32_t bwait;
	PD *p;
	int16_t selst, nrmst, dummy;

	UNUSED(lrets);
	UNUSED(tree);
	UNUSED(bwait);
	
	pwin = srchwp(w_handle);

	message = 0;						/* initialize message */

	/* if window is top window, handle control points */

	if (w_handle == gl_wtop)
	{
		/* changed ROOT to W_BOX 072691 - ml. */
		gadget = cpt = ob_find((LPTREE)pwin->obj, W_BOX, MAX_DEPTH, mx, my);
		nrmst = pwin->obj[gadget].ob_state & ~SELECTED;
		selst = nrmst | SELECTED;
		r_get(&pwin->w_curr, &x, &y, &w, &h);
		kind = pwin->w_kind;				/* fix 10/21/85 */

		ob_gclip((LPTREE)pwin->obj, gadget, &dummy, &dummy, &f.g_x, &f.g_y, &f.g_w, &f.g_h);
#if 0
		f.g_w = pwin->obj[gadget].ob_width;
		f.g_h = pwin->obj[gadget].ob_height;
	    	ob_offset(pwin->obj, gadget, &f.g_x, &f.g_y);
		f.g_x -= ADJ3DPIX;
		f.g_y -= ADJ3DPIX;
		f.g_w += (ADJ3DPIX << 1);
		f.g_h += (ADJ3DPIX << 1);	
#endif
		gsx_sclip(&f);

		switch (cpt)
		{
		case W_CLOSER:
		case W_FULLER:
			if (gr_watchbox(pwin->obj, gadget, selst, nrmst))
			{
				message = (gadget == W_CLOSER) ? WM_CLOSED : WM_FULLED;
			}
			break;
		case W_NAME:
			if (kind & MOVER)
			{
				ob_change((LPTREE)pwin->obj, gadget, selst, TRUE);
				/* prevent the mover gadget being moved completely offscreen */
				r_set(&f, 0, gl_hbox, (gl_rscreen.g_w + w - gl_wbox - 6), 10000);
				gr_dragbox(w, h, x, y, &f, &x, &y);
				message = WM_MOVED;
			}
			break;

/* For debugging tobot() */
#if 0
		case W_INFO:
/*		tobot(w_handle);	*/
			break;
#endif

		case W_SIZER:
			if (kind & SIZER)
			{							/* fix 10/21/85 */
				ob_change((LPTREE)pwin->obj, gadget, selst, TRUE);
				t = *(GRECT *) & (pwin->obj[W_WORK].ob_x);
				t.g_x -= x;
				t.g_y -= y;
				t.g_w -= w;
				t.g_h -= h;
				wm_min(kind, &wm, &hm);
				gr_rubwind(x, y, wm, hm, &t, &w, &h);
				message = WM_SIZED;
			}
			break;
		case W_HSLIDE:
		case W_VSLIDE:
			ob_offset((LPTREE)pwin->obj, cpt + 1, &xelev, &yelev);
			if (cpt == W_HSLIDE)
			{
				/* fix up for index into gl_wa */
				if (!(mx < xelev))
					cpt += 1;
			} else
			{
				if (!(my < yelev))
					cpt += 1;
			}
			/* fall thru */
		case W_UPARROW:
		case W_DNARROW:
		case W_LFARROW:
		case W_RTARROW:
			message = WM_ARROWED;
			break;
		case W_HELEV:
		case W_VELEV:
			message = (cpt == W_HELEV) ? WM_HSLID : WM_VSLID;
			ob_change((LPTREE)pwin->obj, gadget, selst, TRUE);
			/* slide is 1 less than elev */
			x = gr_slidebox((LPTREE)pwin->obj, cpt - 1, cpt, cpt == W_VELEV);
			break;
		}

		if (message == WM_ARROWED)
		{
			if (gadget != W_HSLIDE && gadget != W_VSLIDE)
				ob_change((LPTREE)pwin->obj, gadget, selst, TRUE);
			x = gl_wa[cpt - W_UPARROW];
			wm_update(END_UPDATE);			/* give up the screen */
			cpt = TRUE;
			p = pwin->w_owner;

			do
			{
				if (p->p_stat == PS_MWAIT)
				{
					ap_sendmsg(appl_msg, message, pwin->w_owner->p_pid, w_handle, x, y, w, h);
				} else
				{
					if (!p->p_msgtosend)
					{					/* message is sent */
						p->p_msgtosend = TRUE;						p->p_message[0] = message;		/* message */
						p->p_message[1] = rlr->p_pid;	/* sender */
						p->p_message[2] = 0;			/* extra size in bytes */
						p->p_message[3] = w_handle;
						p->p_message[4] = x;
						p->p_message[5] = y;
						p->p_message[6] = w;
						p->p_message[7] = h;
					}
				}

				dsptch();

				/*
				 * Delay for half current double click time: 
				 * allow button to come back up on single click
				 */
				if (cpt)
				{						/* Only delay 1st time through */
					cpt = FALSE;
					delay((int32_t) gl_dclick);
				}

			} while (button & 1);		/* button is global */

			wm_update(BEG_UPDATE);			/* take back the screen */
			if (gadget != W_HSLIDE && gadget != W_VSLIDE)
			{
				ob_gclip((LPTREE)pwin->obj, gadget, &dummy, &dummy, &f.g_x, &f.g_y, &f.g_w, &f.g_h);

#if 0
				f.g_w = pwin->obj[gadget].ob_width;
				f.g_h = pwin->obj[gadget].ob_height;
		    		ob_offset((LPTREE)pwin->obj, gadget, &f.g_x, &f.g_y);
				f.g_x -= ADJ3DPIX;
				f.g_y -= ADJ3DPIX;
				f.g_w += (ADJ3DPIX << 1);
				f.g_h += (ADJ3DPIX << 1);	
#endif
				gsx_sclip(&f);
				ob_change((LPTREE)pwin->obj, gadget, nrmst, TRUE);
			}
			return;
		}
	} else
	{
		/* if window is not top, tell application to bring it to top */
		message = WM_TOPPED;
	}

	/* BUG: x, y, w, h undefined if w_handle != gl_wtop */
	if (message)
		ct_msgup(message, pwin->w_owner->p_pid, w_handle, x, y, w, h);

	if (message && (message != WM_TOPPED))
		ob_change((LPTREE)pwin->obj, gadget, nrmst, TRUE);

#else

	register WINDOW *pwin;
	GRECT t, f;
	int16_t x, y, w, h;
	int16_t kind;
	int16_t px, py;
	OBJECT *tree;
	int16_t pw, ph;
	register int wm, hm;
	register int16_t message;
	register int16_t cpt;
	int16_t selst, nrmst, dummy;
	int16_t unused[3];
	PD *p;
	
	UNUSED(unused);
	UNUSED(dummy);
	UNUSED(nrmst);
	UNUSED(selst);
	UNUSED(pw);
	UNUSED(ph);
	
	pwin = srchwp(w_handle);
	message = 0;
	if (w_handle == gl_wtop /* ||
		((D.w_win[w_handle].w_flags & VF_SUBWIN) && (D.w_win[gl_wtop].w_flags & VF_SUBWIN)) */ )
	{
		/* 
		 * went down on active window so handle control points
		 */
		w_bldactive(w_handle);
		tree = gl_awind;
		UNUSED(tree);
#if BINEXACT
		cpt = ob_find((LPTREE)gl_awind, 10L, mx, my); /* sigh */
#else
		cpt = ob_find((LPTREE)gl_awind, 0, 10, mx, my);
#endif
        w_getsize(WS_CURR, w_handle, &t);
        r_get(&t, &x, &y, &w, &h);
		kind = pwin->w_kind;
		switch (cpt)
		{
		case W_CLOSER:
#if 0
			/*
			 * MagiC feature not supported by TOS;
			 * HOTCLOSE (0x1000) was later used for menubars (MENUBAR) in windows
			 */
			if (kind & HOTCLOSE)
			{
				message = WM_CLOSED;
				break;
			}
#endif
			/* else fall thru */
		case W_FULLER:
			if (gr_watchbox(gl_awind, cpt, SELECTED, NORMAL))
			{
				message = (cpt == W_CLOSER) ? WM_CLOSED : WM_FULLED;
				ob_change((LPTREE)gl_awind, cpt, NORMAL, TRUE);
			}
			break;
		case W_NAME:
			if (pwin->w_kind & MOVER)
			{
				/* prevent the mover gadget being moved completely offscreen */
				r_set(&f, 0, gl_hbox, gl_rscreen.g_w + w - gl_wbox - 6, 10000);
				gr_dragbox(w, h, x, y, &f, &x, &y);
				message = WM_MOVED;
			}
			break;
		case W_SIZER:
			if (kind & SIZER)
			{
				w_getsize(WS_WORK, w_handle, &t);
				t.g_x -= x;
				t.g_y -= y;
				t.g_w -= w;
				t.g_h -= h;
				wm = gl_wchar;
				hm = gl_hchar;
				if (pwin->w_kind & (LFARROW | RTARROW | HSLIDE))
					wm = gl_wbox * 7;
				if (pwin->w_kind & (UPARROW | DNARROW | VSLIDE))
					hm = gl_hbox * 7;
				gr_rubwind(x, y, wm, hm, &t, &w, &h);
				message = WM_SIZED;
			}
			break;
		case W_HSLIDE:
		case W_VSLIDE:
			/*
			 * cpt + 1: W_HSLIDE -> W_HELEV, W_VSLIDE -> W_VELEV
			 */
			ob_offset((LPTREE)gl_awind, cpt + 1, &px, &py);
			if (cpt == W_HSLIDE)
			{
				/* fix up for index into gl_wa */
				if (!(mx < px))
					cpt += 1;
			} else
			{
				if (!(my < py))
					cpt += 1;
			}
			/* fall thru */
		case W_UPARROW:
		case W_DNARROW:
		case W_LFARROW:
		case W_RTARROW:
			message = WM_ARROWED;
			break;
		case W_HELEV:
		case W_VELEV:
			message = (cpt == W_HELEV) ? WM_HSLID : WM_VSLID;
			/* slide is 1 less than elev */
			x = gr_slidebox((LPTREE)gl_awind, cpt - 1, cpt, cpt == W_VELEV);
			break;
		}
		if (message == WM_ARROWED)
		{
			x = gl_wa[cpt - W_UPARROW];
			wm_update(END_UPDATE);			/* give up the screen */
			cpt = TRUE;
			p = pwin->w_owner;

			do
			{
				if (p->p_stat == PS_MWAIT)
				{
					ap_sendmsg(appl_msg, message, pwin->w_owner->p_pid, w_handle, x, y, w, h);
				} else
				{
					if (!p->p_msgtosend)
					{					/* message is sent */
						p->p_msgtosend = TRUE;
						p->p_message[0] = message;	/* message */
						p->p_message[1] = rlr->p_pid;	/* sender */
#if BINEXACT
						p->p_message[2] = 16;	/* size in bytes */ /* BUG: should be extra size > 16 only */
#else
						p->p_message[2] = 0;	/* extra size in bytes */
#endif
						p->p_message[3] = w_handle;
						p->p_message[4] = x;
						p->p_message[5] = y;
						p->p_message[6] = w;
						p->p_message[7] = h;
					}
				}

				dsptch();

				/*
				 * Delay for half current double click time: 
				 * allow button to come back up on single click
				 */
				if (cpt)
				{						/* Only delay 1st time through */
					cpt = FALSE;
					delay((int32_t) gl_dclick);
				}

			} while (button & 1);		/* button is global */

			wm_update(BEG_UPDATE);			/* take back the screen */
			return;
		}
	} else
	{
        /*
         * went down on inactive window so tell ap. to bring it to top
         */
		message = WM_TOPPED;
#if 0 & SINGLAPP
		ct_msgup(WM_UNTOPPED, D.w_win[gl_wtop].w_owner->p_pid, gl_wtop, x, y, w, h);
	    for (i = 0; i < NUM_ACCS; i++)
    	    dsptch();
#endif
	}
	/* BUG: x, y, w, h undefined if w_handle != gl_wtop */
	ct_msgup(message, pwin->w_owner->p_pid, w_handle, x, y, w, h);
#endif
}


/* 306de: 00e1b580 */
VOID hctl_button(P(int16_t) mx, P(int16_t) my)
PP(register int16_t mx;)
PP(register int16_t my;)
{
	register int16_t wh;

	/* find out which wind. the mouse clicked over and handle it */

	if ((wh = wm_find(mx, my)) > 0)
		hctl_window(wh, mx, my);
}


/* 306de: 00e1b5b6 */
VOID hctl_rect(P(int16_t) mx, P(int16_t) my)
PP(int16_t mx;)
PP(int16_t my;)
{
	int16_t title, item;
	register int16_t owner, mesag;
#if SUBMENUS
	LPTREE ptree;
	int16_t pmenu;
	int16_t keyret;
#endif

	if (gl_mntree != 0 && inside(mx, my, &gl_rmnactv))
	{
		mesag = 0;
#if !BINEXACT
		owner = 0;
#endif
#if SUBMENUS
		if (mn_hdo(&title, &ptree, &pmenu, &item, &keyret))
#else
		if (mn_do(&title, &item))
#endif
		{
			/* check system menu: title == 1st menu && item == deskacc */
			if (gl_dacnt && title == THEDESK && item >= gl_dabase)
			{
				item -= gl_dabase;
				owner = desk_pid[item];
				do_chg(gl_mntree, title, SELECTED, FALSE, TRUE, TRUE);
				mesag = AC_OPEN;
			} else
			{
				owner = gl_mnpid;
				mesag = MN_SELECTED;
			}
		}
		/* application menu item has been selected so send it */
#if SUBMENUS
#if BINEXACT
		/* WTF, another of these hacks passing 2 shorts as long */
		ct_msgup(mesag, owner, title, item, ptree, pmenu);
#else
		/* and another BUG: owner used uninitialized */
		ct_msgup(mesag, owner, title, item, LHIWD(ptree), LLOWD(ptree), pmenu);
#endif
#else
#if BINEXACT
		ct_msgup(mesag, owner, title, item, NULL, 0);
#else
		ct_msgup(mesag, owner, title, item, 0, 0, 0);
#endif
#endif
	}
}


#if AES3D
static VOID drawdesk PROTO((int16_t x, int16_t y, int16_t w, int16_t h));

/*
 * hctl_msg() - handle messages received by control manager
 *		(currently only redraw message is handled)
 */
static VOID hctl_msg(P(int16_t *) msgbuf)
PP(int16_t *msgbuf;)
{
	if (msgbuf[0] == WM_REDRAW)
		drawdesk(msgbuf[4], msgbuf[5], msgbuf[6], msgbuf[7]);
}


/*
 * drawdesk() - redraw portion of DESKTOP specified by the 
 *		given rectangle
 */
static VOID drawdesk(P(int16_t) x, P(int16_t) y, P(int16_t) w, P(int16_t) h)
PP(int16_t x;)
PP(int16_t y;)
PP(int16_t w;)
PP(int16_t h;)
{
	GRECT t1, t2;
	int16_t temp[4];
	OBJECT *tree;
	int16_t stobj;

	gsx_moff();
	wm_update(BEG_UPDATE);
	t2.g_x = x;
	t2.g_y = y;
	t2.g_w = w;
	t2.g_h = h;
#if (AES3D) & !BINEXACT
	wm_get(deskwind, WF_FIRSTXYWH, temp, NULL);
#else
	wm_get(deskwind, WF_FIRSTXYWH, temp); /* BUG: missing parameter for >= 0x0330 */
#endif

	if (gl_newdesk)
	{
		tree = (OBJECT *) gl_newdesk;
		stobj = gl_newroot;
	} else
	{
		tree = (OBJECT *) ad_stdesk;
		stobj = ROOT;
	}

	while (temp[2] && temp[3])
	{
		t1 = *(GRECT *) temp;
		if (rc_intersect(&t2, &t1))
		{
			gsx_sclip(&t1);
			ob_draw((LPTREE)tree, stobj, MAX_DEPTH);
		}
#if (AES3D) & !BINEXACT
		wm_get(deskwind, WF_NEXTXYWH, temp, NULL);
#else
		wm_get(deskwind, WF_NEXTXYWH, temp); /* BUG: missing parameter for >= 0x0330 */
#endif
	}

	wm_update(END_UPDATE);
	gsx_mon();
}
#endif


/*
 *	Control change of ownership to this rectangle and this process
 *	Doing the control rectangle first is important.
 */
/* 306de: 00e1b67a */
VOID ct_chgown(P(PD *) ppd, P(GRECT *) pr)
PP(PD *ppd;)
PP(GRECT *pr;)
{
	/* set_ctrl(pr), copy the rect into control */
	rc_copy(pr, &ctrl);
	/* set_mkown(ppd, ppd);     */

	/* change the owner */
	gl_cowner = gl_mowner = ppd;
	/* pretend mouse moved to get the right form showing */
	/* and get mouse event posted correctly */
	post_mouse(gl_mowner, xrat, yrat);
	/* post a button event in case the new owner was waiting */
#if AESVERSION <= 0x320
	post_button(gl_mowner, button, 1);
#endif

	gl_kowner = ppd;
}


/*
 *	Internal process context used to control the screen for use by
 *	the menu manager, and the window manager.
 *	This process never terminates and forms an integral part of
 *	the system.
 */
/* 306de: 00e1b6de */
int16_t ctlmgr(NOTHING)
{
	register int16_t ev_which;
	int16_t lrets[6];
#if AES3D
	int16_t msgbuf[8];
#endif

	/* set defaults for multi wait */
	rc_copy(&gl_rmenu, (GRECT *)&gl_ctwait.m_x);
	gl_ctwait.m_out = FALSE;			/* CHANGED LKW      */


	while (1)
	{
		w_setactive();
		/*
		 * if no waiting to go out of menu area
		 * then give mouse to owner of top window
		 */
		/* gsx_mxmy(&mx, &my); */
		/* gl_ctwait.m_out = inside(mx, my, &gl_ctwait.m_x); */

		/* wait for something to happen */
#if AES3D
		ev_which = ev_multi(MU_KEYBD | MU_BUTTON | MU_M1 | MU_MESAG, &gl_ctwait, &gl_ctwait, 0x0L, 0x0001ff01L, msgbuf, lrets);
#else
		ev_which = ev_multi(MU_KEYBD | MU_BUTTON | MU_M1, &gl_ctwait, &gl_ctwait, 0x0L, 0x0001ff01L, NULL, lrets);
#endif
		/* grab screen sink */
		wm_update(BEG_UPDATE);
		/* button down over area ctrl mgr owns  */
		if (ev_which & MU_BUTTON)
		{
			hctl_button(lrets[0], lrets[1]);
		}
		/* mouse over menu bar */
		if (ev_which & MU_M1)
		{
			hctl_rect(lrets[0], lrets[1]);
		}

#if AES3D
		if (ev_which & MU_MESAG)		/* need to redraw */
		{
			hctl_msg(msgbuf);
		}
#endif

		/* give up screen sink */
		wm_update(END_UPDATE);
	}
}


/*
 *	Create a process for the Screen Control Manager and start him 
 *	executing. Also do all the initialization that is required.  
 *	Also zero out the desk accessory count.
 */
/* 306de: 00e1b770 */
PD *ictlmgr(P(int16_t) pid)
PP(int16_t pid;)
{
	PD *px;
	register int32_t ldaddr;

	UNUSED(px);
	gl_dacnt = 0;
	gl_dabase = 0;
	/* figure out load addr */
	ldaddr = LLCS() + ((int32_t) & ctlmgr);
	/* create process to    */
	/* execute it       */
	return (pstart(&ctlmgr, "SCRENMGR.LOC", ldaddr));
}


/*
 * New routine to force arrow mouse and show mouse when it is over
 * the menu bar or there is an alert box	3/05/86
 */
/* 306de: 00e1b7aa */
VOID ctlmouse(P(BOOLEAN) mon)
PP(BOOLEAN mon;)
{
	if (mon)							/* turn on and show the mouse   */
	{
		getmouse();
		tmpmon = gl_mouse;				/* mouse on flag        */
		tmpmoff = gl_moff;
		gsx_xmfset(ad_armice);			/* change the mouse form    */
		if (!gl_mouse)					/* if currently the mouse is    */
		{
			gsx_1code(SHOW_CUR, 0);		/* off, then turn it on     */
			gl_mouse = TRUE;			/* set the flag         */
		}
		gl_moff = 0;					/* reset the flag to make bbset */
	} else
	{
#if BINEXACT /* sigh */
		gsx_ncode(HIDE_CUR, 0L);		/* turn off the mouse anyway    */
#else
		gsx_ncode(HIDE_CUR, 0, 0);		/* turn off the mouse anyway    */
#endif
		putmouse();						/* put the mouse back to the    */
		gl_mouse = FALSE;				/* way it was           */

		if (tmpmon)						/* the mouse was on     */
		{
#if BINEXACT
			gsx_ncode(SHOW_CUR, 0L); /* sigh */
#else
			gsx_ncode(SHOW_CUR, 0, 0);
#endif
			gl_mouse = TRUE;
		}

		gl_moff = tmpmoff;
	}
}



/*	0 = end mouse control	*/
/*	1 = mouse control	*/

/* 3066de: 00e1b846 */
VOID take_ownership(P(BOOLEAN) beg_ownit)
PP(BOOLEAN beg_ownit;)
{
	if (beg_ownit)
	{
		wm_update(BEG_UPDATE);
		if (ml_ocnt == 0)
		{
			ml_mnhold = gl_mntree;		/* save the current menu   */
			gl_mntree = 0;				/* no menu         */
			rc_copy(&ctrl, &ml_ctrl);	/* get_ctrl(&ml_ctrl);     */
			/* save the control rect */
			/* get_mkown(&ml_pmown, &ml_pkown); */

			ml_pmown = gl_mowner;		/* save the mouse owner    */
			ml_pkown = gl_kowner;		/* save the keyboard owner */

			ct_chgown(rlr, &gl_rscreen);	/* change mouse ownership  */
		}								/* and the control rect    */
		ml_ocnt++;
	} else
	{
		ml_ocnt--;
		if (ml_ocnt == 0)
		{
			ct_chgown(ml_pkown, &ml_ctrl);	/* restore mouse owner     */ /* BUG: ml_pkown is keyboard owner, not mouse */
			gl_mntree = ml_mnhold;		/* restore menu tree       */
		}
		wm_update(END_UPDATE);
	}
}
